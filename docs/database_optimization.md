# データベース最適化ガイド

このドキュメントでは、StudySparkアプリケーションにおけるデータベースの最適化戦略について説明します。

## インデックス設計

以下のテーブルに対して、主要なクエリパターンに基づいてインデックスを設計しました。

### 高頻度アクセステーブル

#### question_attempt_logs

このテーブルは学習履歴を記録するため、非常に高い頻度でアクセスされます。

- **`(user_id, date)`**: ユーザーごとの日別学習履歴取得に最適化
- **`(user_id, status)`**: ユーザーごとのステータス（完了、未完了など）で学習履歴をフィルタリング
- **`(question_id, date)`**: 特定の問題の日別進捗を追跡

#### learning_tasks

学習タスクのスケジュールと管理に使用されるテーブル。

- **`(plan_id, date)`**: 学習計画ごとの日別タスク一覧取得に最適化
- **`(date, is_review_day)`**: 復習日かどうかでタスクをフィルタリング

### その他の最適化テーブル

#### goals

- **`(user_id, test_start_date, test_end_date)`**: ユーザーごとのテスト日程でゴールをフィルタリング

#### learning_plans

- **`(user_id)`**: ユーザーごとの学習計画一覧取得
- **`(goal_id)`**: ゴールごとの学習計画取得

#### daily_reflections, weekly_reflections

- **`(user_id, date)`**/**`(user_id, week_start, week_end)`**: ユーザーごとの日別/週別振り返りデータ取得

#### value_prompts, reflection_badges

- **`(user_id, prompt_type)`**/**`(user_id, badge_type)`**: ユーザーごとのタイプ別データ取得

## クエリ最適化ガイドライン

StudySparkアプリケーションで効率的なクエリを書くためのガイドライン：

1. **常にインデックスを活用**
   - WHERE句では、上記のインデックスフィールドを条件に含める
   - 複合インデックスは左端のカラムから使用する（例：`(user_id, date)`インデックスを使うなら、WHERE句にuser_idを含める）

2. **JOINの最小化**
   - 必要なデータだけを選択し、過剰なJOINを避ける
   - 大きなJOINが必要な場合は、ページネーションを検討する

3. **集計クエリの最適化**
   - 大量データの集計はバックグラウンドジョブで事前計算を検討
   - 集計結果のキャッシュを検討（特に変更頻度が低いデータの場合）

4. **ページネーションの活用**
   - 大量データを返す可能性があるクエリには常にLIMITとOFFSETを使用
   - カーソルベースのページネーション（IDを基準にした次のページ取得）を優先

5. **効率的なフィルタリング**
   - 範囲検索よりも等価検索を優先（可能な場合）
   - 複合条件ではANDを優先（ORは複数のインデックスを使えない場合がある）

## パフォーマンスモニタリング

- **高負荷クエリの監視**: 特に`question_attempt_logs`テーブルへのアクセスは注意深く監視
- **実行時間の長いクエリを特定**: Supabaseダッシュボードを活用
- **インデックス使用状況の確認**: EXPLAINコマンドを使用して実際のクエリプランを確認

## スケーリング戦略

データ量が増加した際のスケーリング戦略：

1. **パーティショニングの検討**
   - `question_attempt_logs`テーブルは日付でパーティショニングを検討（データが非常に多くなる場合）

2. **定期的なデータアーカイブ**
   - 古いログデータは別テーブルにアーカイブ

3. **キャッシュ層の追加**
   - 頻繁にアクセスされる読み取り専用データにはRedisなどのキャッシュ導入を検討

4. **データベースの垂直/水平スケーリング**
   - 必要に応じてSupabaseのプランをアップグレード
   - 長期的には読み取り専用レプリカの追加も検討

このガイドラインに従うことで、アプリケーションの成長に合わせて効率的なデータベースアクセスを維持できます。 